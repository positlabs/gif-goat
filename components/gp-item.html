<!-- 

	TODO 

	- output options
		- max-height, max-width

	- no transparency pixel on gifs
	- paletteuse adds ~3x file size. why?

	- preview gif button

-->

<link rel='import' href='./gp-thumbnail.html'>
<link rel='import' href='./gp-progress-bar.html'>

<dom-module id='gp-item'>

	<style>

		:host {
			display: block;
			position: relative;
			width: 100%; height: 50px;
			margin: 10px 0;
			cursor: default;
			overflow: hidden;
			color: var(--dark-purple);
		}

		#thumb, #progress, #filename {
			float: left;
		}

		#thumb {
			margin-left: 20px;
		}

		#filename {
			margin-left: 20px;
			line-height: 50px;
			font-size: .8em;
		}

		.btns {
			position: absolute;
			right: 20px; top: 50%;
			transform: translateY(-50%);
		}
		.btns .btn {
		}

		#open-btn {
			display: none;
		}

	</style>
	
	<template>

		<gp-thumbnail id='thumb'></gp-thumbnail>
		<!-- <div id='state'>[[state]]</div> -->
		<div id='filename' title='[[file.path]]'>[[file.path]]</div>
		<div id='progress'></div>

		<div class='btns'>
			<div id='open-btn' class='btn fa fa-external-link-square' on-click='_open'></div>
			<div id='remove-btn' class='btn fa fa-close' on-click='_remove'></div>
		</div>


	</template>

	<script>(function(){

		const fs = require('fs');
		const path = require('path');
		const paths = require('./modules/paths');
		const shell = require('electron').shell;
		const ffmpeg = require('fluent-ffmpeg');
		const ffmpegPath = require('./modules/ffmpeg-static').ffmpeg;
		const ffprobePath = require('./modules/ffmpeg-static').ffprobe;
		ffmpeg.setFfmpegPath(ffmpegPath);
		ffmpeg.setFfprobePath(ffprobePath);
		console.log(ffmpegPath);

		var states = {
			ready: 'ready',
			processing: 'processing',
			done: 'done',
		};
		
		Polymer({
			is: 'gp-item',

			properties: {
				file: {
					type: Object,
					observer: '_onFileChanged'
				},
				state: {
					type: String,
					readOnly: true,
					value: states.ready,
					notify: true,
					observer: '_onStateChanged'
				},
				progress: {
					type: Number,
					value: 0,
					readOnly: true
				}
			},

			_onStateChanged(){
				switch(this.state){

					case states.ready:

						break;

					case states.processing:
						// show progress bar

						break;

					case states.done:
						//TODO: use visibility
						// hide close butn
						this.$['remove-btn'].style.display = 'none';
						// show folder button
						this.$['open-btn'].style.display = 'block';

						// show preview button

						break;

				}
			},

			_onFileChanged(){
				console.log(this.localName, '_onFileChanged');
				this.$.filename.innerHTML = path.basename(this.file.path);
				this.$.thumb.video = this.file.path;
			},

			_generatePalette(){
				var settings = this._settings;
				
				return new Promise( (resolve, reject) => {
					this.paletteCommand = ffmpeg(this.file.path)
						.on('start', commandLine => {
							// console.log('Spawned Ffmpeg with command: ' + commandLine);
						})
						.videoFilters([
							'palettegen'
						])
						.on('error', e => {
							console.log(e);
							reject(e);
						})
						.on('end', () => {
							resolve();
						});

						if(settings.fps){
							this.paletteCommand.fps(settings.fps);
						}

						this.paletteCommand.save( this._getPalettePath(this.file.path) );

					// console.log(this.paletteCommand);

				}).catch( err => { console.log(err); } );
			},

			_getPalettePath(name){
				return path.join(paths.temp, 'palette_' + path.basename(name) + '.png');
			},
			_getGIFPath(name){
				// console.log('_getGIFPath', this, name);
				return path.join(this._settings.output, path.basename(name) + '.gif')
			},

			_encodeGIF(){
				var settings = this._settings;

				return new Promise( (resolve, reject) => {

					this.ffmpegCommand = ffmpeg()
						.input(this.file.path)
						.input(this._getPalettePath(this.file.path))
						// .fps(settings.fps)
						.outputOptions([
							'-lavfi paletteuse'
						])
						.on('start', commandLine => {
							// console.log('Spawned Ffmpeg with command: ' + commandLine);
						})
						.on('progress', progress => {
							console.log('progress', progress.percent);
							this._setProgress(progress.percent);
							this.$.progress.innerHTML = Math.round(progress.percent) + '%';
						})
						.on('error', (err, stdout, stderr) => {
							console.log('Cannot process video: ' + err.message);
							//TODO: display error message in parent
							reject(err.message);
						})
						.on('end', () => {
							console.log('Transcoding succeeded!');
							this._setProgress(100);
							this.$.progress.innerHTML = '100%';
							this._setState('done');
							resolve();
						})

						if(settings.fps){
							this.ffmpegCommand.fps(settings.fps);
						}

						// TODO
						// this.ffmpegCommand.size('720x?')

						this.ffmpegCommand.save( this._getGIFPath(this.file.path) );
				});
			},

			run(settings){

				// only run the encoding process once
				if(this.runPromise !== undefined) return this.runPromise;
				
				this._settings = settings;
				
				this._setState('processing');

				this.runPromise = 
					this._generatePalette()
					.then(() => {
						this._encodeGIF();
					});

				return this.runPromise;
			},

			_open(){
				// console.log('_open', this);
				shell.showItemInFolder( this._getGIFPath(this.file.path) );
			},

			_remove(){
				TweenMax.to(this, .3, {height: 0, ease: Power3.easeOut, onComplete: ()=>{
					this.remove();
				}});
			},

			detached(){
				this.fire('detached');
				//TODO: cancel any ffmpeg processes
			}

		});

	})();</script>

</dom-module>