<!-- 


-->

<link rel='import' href='./gp-thumbnail.html'>
<link rel='import' href='./gp-progress-bar.html'>

<link rel="stylesheet" type="text/css" href="../styles/sweetalert.css">

<dom-module id='gp-item'>

	<style>

		:host {
			display: block;
			position: relative;
			width: 100%; height: 50px;
			margin: 10px 0;
			cursor: default;
			overflow: hidden;
			color: white;
		}

		#thumb, #progress, #filename {
			float: left;
		}

		#thumb {
			margin-left: 20px;
		}

		#filename {
			margin-left: 20px;
			line-height: 50px;
			font-size: .8em;
		}

		#progressBar {
			position: absolute;
			top: 40px; left: 90px;
			width: -webkit-calc(100% - 150px)
		}

		.btns {
			position: absolute;
			right: 20px; top: 50%;
			transform: translateY(-50%);
			width: 100px;
			font-size: 1.2em;
		}
		.btns .btn {
			display: inline-block;
			float: right;
			padding: 5px;
		}

		.btn:hover {
			color: var(--light-green);
		}

		#open-btn, #preview-btn {
			display: none;
		}

	</style>
	
	<template>

		<gp-thumbnail id='thumb' title='[[state]]'></gp-thumbnail>
		<div id='filename' title='[[file.path]]'>[[file.path]]</div>
		<gp-progress-bar id='progressBar'></gp-progress-bar>
		<div id='progress' hidden></div>

		<div class='btns'>
			<div id='open-btn' class='btn fa fa-external-link-square' on-click='_open' title='show in folder'></div>
			<div id='preview-btn' class='btn fa fa-eye' on-click='_preview' title='preview'></div>
			<div id='remove-btn' class='btn fa fa-close' on-click='_remove' title='remove'></div>
		</div>


	</template>

	<script>(function(){

		const fs = require('fs');
		const path = require('path');
		const paths = require('./modules/paths');
		const glob = require('glob');
		const shell = require('electron').shell;
		const remote = require('electron').remote;
		const argv = require('yargs').argv;
		const ffmpeg = require('fluent-ffmpeg');
		const ffmpegPath = require('./modules/ffmpeg-static').ffmpeg.replace('app.asar', 'app.asar.unpacked');
		const ffprobePath = require('./modules/ffmpeg-static').ffprobe.replace('app.asar', 'app.asar.unpacked');
		ffmpeg.setFfmpegPath(ffmpegPath);
		ffmpeg.setFfprobePath(ffprobePath);
		console.log(ffmpegPath);

		const execFile = require('child_process').execFile;
		// const gifsicle = require('gifsicle');
		const gifsicle = __dirname.replace('app.asar', 'app.asar.unpacked') + '/bin/gifsicle/gifsicle';

		const swal = require('sweetalert');

		const states = {
			ready: 'ready',
			processing: 'processing',
			done: 'done',
		};
		
		Polymer({
			is: 'gp-item',

			properties: {
				file: {
					type: Object,
					observer: '_onFileChanged'
				},
				state: {
					type: String,
					readOnly: true,
					value: states.ready,
					notify: true,
					observer: '_onStateChanged'
				},
				progress: {
					type: Number,
					value: 0,
					readOnly: true
				}
			},

			created(){
				this._getGIFPath = _.memoize(this._getGIFPath).bind(this);
			},

			_onStateChanged(){
				switch(this.state){

					case states.ready:
						this.$.progressBar.show();

						break;

					case states.processing:
						// show progress bar
						this.$.thumb.processing();

						break;

					case states.done:
						this.$.thumb.done();
						this.$.progressBar.hide();

						// hide close button
						this.$['remove-btn'].style.display = 'none';

						// show folder button
						this.$['open-btn'].style.display = 'block';
						this.$['preview-btn'].style.display = 'block';

						// show preview button

						// show gif name
						this._getGIFPath(this.file.path).then(gifPath => {
							this.$.filename.innerHTML = path.parse(gifPath).name + '.gif';
						});

						this.fire('done');

						break;

				}
			},

			_onFileChanged(){
				console.log(this.localName, '_onFileChanged');
				this.$.filename.innerHTML = path.basename(this.file.path);
				this.$.thumb.video = this.file.path;
			},

			__setProgress(percent){
				console.log('__setProgress', percent);
				this._setProgress(percent);
				this.$.progress.innerHTML = Math.round(percent) + '%';
				this.$.progressBar.progress = percent;
			},

			_generatePalette(){
				var settings = this._settings;
				var scaleFilter = this._getScaleFilter();
				var videoFilter = `-lavfi ${scaleFilter}palettegen=max_colors=${settings.colors}`;
				console.log(videoFilter);
				
				return new Promise( (resolve, reject) => {
					this.paletteCommand = ffmpeg(this.file.path)
						.on('start', commandLine => {
							// console.log('Spawned Ffmpeg with command: ' + commandLine);
						})
						// .videoFilters([
						// 	`palettegen --max_colors=${settings.colors}`
						// ])
						.outputOptions([
							videoFilter
						])
						.on('error', e => {
							console.log(e);
							reject(e);
						})
						.on('progress', progress => {
							// faiils...
							// console.log(`palette progress: ${progress.percent}`);
							// this.__setProgress(progress.percent/2);
						})
						.on('end', () => {
							resolve();
						});

					if(settings.fps){
						this.paletteCommand.fps(settings.fps);
					}

					this.paletteCommand.save( this._getPalettePath(this.file.path) );

				}).catch( err => { console.log(err); } );
			},

			_getPalettePath(filepath){
				// return path.join(paths.temp, 'default-palette.png');
				return path.join(paths.temp, 'palette_' + path.parse(filepath).name + '.png');
			},
			_getGIFPath: function(filepath){
				console.log('_getGIFPath', filepath);
				return new Promise((resolve, reject) => {
					// if(this._gifPath) {
					// 	resolve(this._gifPath);
					// 	return;
					// }

					var gifName = path.parse(filepath).name;
					// check if file exists or not
					glob(path.join(this._settings.output, '*.gif'), {}, (err, files) => {
						if(err){
							console.log(err);
							reject(err.message);
							return;
						}

						var filepaths = files.map(file => { return path.parse(file).name; });
						console.log('globbed gifs', filepaths);

						var modifier = '';
						var checkName = gifName;
						while(filepaths.indexOf(checkName) !== -1){
							if(modifier === '') modifier = 1;
							else modifier += 1;
							checkName = gifName + '(' + modifier + ')';
						}
						this._gifPath = path.join(this._settings.output, checkName + '.gif');
						resolve(this._gifPath);
					});

				});
			},

			_getScaleFilter(){
				var settings = this._settings;
				var w = (settings.width.length && settings.width > 0) ? settings.width : '-1',
					h = (settings.height.length && settings.height > 0) ? settings.height : '-1';
				var scaleFilter = 'scale=' + [w, h, 'flags=lanczos'].join(':') + ',';
				if(w+h === '-1-1') scaleFilter = '';
				return scaleFilter;
			},

			_encodeGIF(){
				var settings = this._settings;

				return new Promise( (resolve, reject) => {

					var scaleFilter = this._getScaleFilter();
					var filterOptions = '-lavfi ' + scaleFilter + 'paletteuse=dither=floyd_steinberg'
					console.log(filterOptions);

					this.ffmpegCommand = ffmpeg()
						.input(this.file.path)
						// .input(path.join(paths.temp, 'default-palette.png'))
						.input(this._getPalettePath(this.file.path))
						.outputOptions([ filterOptions ])
						.on('start', commandLine => {
							// console.log('Spawned Ffmpeg with command: ' + commandLine);
						})
						.on('progress', progress => {
							console.log('progress', progress);
							this.__setProgress(progress.percent);
						})
						.on('error', (err, stdout, stderr) => {
							console.log('Cannot process video: ' + err.message);
							reject(err.message);
						})
						.on('end', () => {
							// console.log('Transcoding succeeded!');
							this._setProgress(100);
							this.$.progress.innerHTML = '100%';
							this.$.progressBar.progress = 100;
							this._setState('done');
							resolve();
						})

						if(settings.fps){
							this.ffmpegCommand.fps(settings.fps);
						}
						this._getGIFPath(this.file.path).then(gifPath => {
							this.ffmpegCommand.save(gifPath);
						});
				});
			},

			_optimizeGIF(){
				var settings = this._settings;

				return new Promise((resolve, reject) => {

					this._getGIFPath(this.file.path).then(gifPath => {

						execFile(gifsicle, [
							'-o',
							gifPath,
							gifPath,
							'-O3' // slow optimization for lower file sizes.
						], err => {
							if(err){
								console.log(err.message);
								reject(err.message);
								return;
							} 
							console.log('Image minified!');
							resolve();
						});
					});
				});
			},

			run(settings){

				// only run the encoding process once
				if(this.runPromise !== undefined) return this.runPromise;
				
				this._settings = settings;

				this._setState('processing');

				this.runPromise = new Promise((resolve, reject) => {
					this._generatePalette()
						.then(this._encodeGIF.bind(this))
						.then(this._optimizeGIF.bind(this))
						.then(resolve)
						.catch(msg => {
							// display error message
							if(msg.match('SIGKILL')) return;
							swal({
								title: 'Error! Baaaaa!', 
								text: msg,
								confirmButtonColor: '#d74802'
							});
						});
				});

				return this.runPromise;
			},

			_open(){
				// console.log('_open', this);
				this._getGIFPath(this.file.path)
					.then(shell.showItemInFolder);
			},

			_remove(){

				if(this.paletteCommand){
					this.paletteCommand.kill([signal='SIGKILL']);
				}
				if(this.ffmpegCommand){
					this.ffmpegCommand.kill([signal='SIGKILL']);
				}

				TweenMax.to(this, .3, {height: 0, ease: Power3.easeOut, onComplete: ()=>{
					this.remove();
				}});
			},

			_preview(){

				var img = document.createElement('img');

				var gifPath;
				this._getGIFPath(this.file.path).then(_gifPath => {
					gifPath = _gifPath;
					img.src = 'file://' + _gifPath;
				});

				img.addEventListener('load', e => {
					console.log('opening preview', gifPath);
					ipc.send('open-preview', {
						width: img.width, 
						height: img.height,
						gif: gifPath
					});
				});
			},

			detached(){
				this.fire('detached');
			}

		});

	})();</script>

</dom-module>